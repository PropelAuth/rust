/*
 * propelauth
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error, UserFacingError};
use crate::models::{FetchUsersOrderBy, ResendEmailConfirmationRequest};
use crate::{apis::ResponseContent, models::InviteUserToOrgRequest};

/// struct for passing parameters to the method [`create_magic_link`]
#[derive(Clone, Debug, Default)]
pub struct CreateMagicLinkParams {
    pub create_magic_link_request: crate::models::CreateMagicLinkRequest,
}

/// struct for passing parameters to the method [`create_user`]
#[derive(Clone, Debug, Default)]
pub struct CreateUserParams {
    pub create_user_request: crate::models::CreateUserRequest,
}

/// struct for passing parameters to the method [`delete_user`]
#[derive(Clone, Debug, Default)]
pub struct DeleteUserParams {
    pub user_id: String,
}

/// struct for passing parameters to the method [`disable_user`]
#[derive(Clone, Debug, Default)]
pub struct DisableUserParams {
    pub user_id: String,
}

/// struct for passing parameters to the method [`disable_user2fa`]
#[derive(Clone, Debug, Default)]
pub struct DisableUser2faParams {
    pub user_id: String,
}

/// struct for passing parameters to the method [`enable_user`]
#[derive(Clone, Debug, Default)]
pub struct EnableUserParams {
    pub user_id: String,
}

/// struct for passing parameters to the method [`fetch_user_by_email`]
#[derive(Clone, Debug, Default)]
pub struct FetchUserByEmailParams {
    pub email: String,
    /// Defaults to false
    pub include_orgs: Option<bool>,
}

/// struct for passing parameters to the method [`fetch_user_by_id`]
#[derive(Clone, Debug, Default)]
pub struct FetchUserByIdParams {
    pub user_id: String,
    /// Defaults to false
    pub include_orgs: Option<bool>,
}

/// struct for passing parameters to the method [`fetch_user_by_username`]
#[derive(Clone, Debug, Default)]
pub struct FetchUserByUsernameParams {
    pub username: String,
    /// Defaults to false
    pub include_orgs: Option<bool>,
}

/// struct for passing parameters to the method [`fetch_users_by_emails`]
#[derive(Clone, Debug, Default)]
pub struct FetchUsersByEmailsParams {
    pub emails_query: crate::models::EmailsQuery,
    /// Defaults to false
    pub include_orgs: Option<bool>,
}

/// struct for passing parameters to the method [`fetch_users_by_ids`]
#[derive(Clone, Debug, Default)]
pub struct FetchUsersByIdsParams {
    pub user_ids_query: crate::models::UserIdsQuery,
    /// Defaults to false
    pub include_orgs: Option<bool>,
}

/// struct for passing parameters to the method [`fetch_users_by_query`]
#[derive(Clone, Debug, Default)]
pub struct FetchUsersByQueryParams {
    pub page_size: Option<i64>,
    pub page_number: Option<i64>,
    pub order_by: Option<FetchUsersOrderBy>,
    pub email_or_username: Option<String>,
    pub include_orgs: Option<bool>,
    pub legacy_user_id: Option<String>,
}

/// struct for passing parameters to the method [`fetch_users_by_usernames`]
#[derive(Clone, Debug, Default)]
pub struct FetchUsersByUsernamesParams {
    pub usernames_query: crate::models::UsernamesQuery,
    /// Defaults to false
    pub include_orgs: Option<bool>,
}

/// struct for passing parameters to the method [`migrate_user`]
#[derive(Clone, Debug, Default)]
pub struct MigrateUserParams {
    pub migrate_user_request: crate::models::MigrateUserRequest,
}

/// struct for passing parameters to the method [`update_user_email`]
#[derive(Clone, Debug, Default)]
pub struct UpdateUserEmailParams {
    pub user_id: String,
    pub update_email_request: crate::models::UpdateEmailRequest,
}

/// struct for passing parameters to the method [`update_user_metadata`]
#[derive(Clone, Debug, Default)]
pub struct UpdateUserMetadataParams {
    pub user_id: String,
    pub update_metadata_request: crate::models::UpdateMetadataRequest,
}

/// struct for passing parameters to the method [`update_user_password`]
#[derive(Clone, Debug, Default)]
pub struct UpdateUserPasswordParams {
    pub user_id: String,
    pub update_password_request: crate::models::UpdatePasswordRequest,
}

/// struct for typed errors of method [`create_magic_link`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateMagicLinkError {
    Status400(crate::models::BadCreateMagicLinkRequest),
    Status401(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserError {
    Status400(crate::models::BadCreateUserRequest),
    Status401(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUserError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`disable_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisableUserError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logout_all_user_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogoutAllUserSessionsError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

// struct for typed errors of method [`resend_email_confirmation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResendEmailConfirmationError {
    Status400(UserFacingError),
    Status401(UserFacingError),
    Status404(UserFacingError),
    Status429(UserFacingError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`disable_user2fa`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisableUser2faError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enable_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnableUserError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_user_by_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserByEmailError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_user_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserByIdError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_user_by_username`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserByUsernameError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_users_by_emails`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUsersByEmailsError {
    Status400(crate::models::BadFetchUsersByEmailsQuery),
    Status401(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_users_by_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUsersByIdsError {
    Status400(crate::models::BadFetchUsersByIdsQuery),
    Status401(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_users_by_query`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUsersByQueryError {
    Status400(crate::models::BadFetchUsersByQuery),
    Status401(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_users_by_usernames`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUsersByUsernamesError {
    Status400(crate::models::BadFetchUsersByUsernamesQuery),
    Status401(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`migrate_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MigrateUserError {
    Status400(crate::models::BadMigrateUserRequest),
    Status401(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserEmailError {
    Status400(crate::models::BadUpdateUserEmailRequest),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    Status429(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserMetadataError {
    Status400(crate::models::BadUpdateUserMetadataRequest),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserPasswordError {
    Status400(crate::models::BadUpdatePasswordRequest),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`clear_user_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClearUserPasswordError {
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invite_user_to_org`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InviteUserToOrgError {
    Status400(serde_json::Value),
    Status401(serde_json::Value),
    Status404(serde_json::Value),
    UnknownValue(serde_json::Value),
}

pub async fn create_magic_link(
    configuration: &configuration::Configuration,
    params: CreateMagicLinkParams,
) -> Result<crate::models::MagicLink, Error<CreateMagicLinkError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_magic_link_request = params.create_magic_link_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/magic_link",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_magic_link_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateMagicLinkError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn create_user(
    configuration: &configuration::Configuration,
    params: CreateUserParams,
) -> Result<crate::models::CreatedUserResponse, Error<CreateUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let create_user_request = params.create_user_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/backend/v1/user/", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_user_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn delete_user(
    configuration: &configuration::Configuration,
    params: DeleteUserParams,
) -> Result<crate::models::SuccessfulResponse, Error<DeleteUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/{user_id}",
        local_var_configuration.base_path,
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn disable_user(
    configuration: &configuration::Configuration,
    params: DisableUserParams,
) -> Result<crate::models::SuccessfulResponse, Error<DisableUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/{user_id}/disable",
        local_var_configuration.base_path,
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DisableUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn resend_email_confirmation(
    configuration: &configuration::Configuration,
    user_id: String,
) -> Result<crate::models::SuccessfulResponse, Error<ResendEmailConfirmationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let request = ResendEmailConfirmationRequest { user_id };

    let local_var_uri_str = format!(
        "{}/api/backend/v1/resend_email_confirmation",
        local_var_configuration.base_path,
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ResendEmailConfirmationError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn logout_all_user_sessions(
    configuration: &configuration::Configuration,
    user_id: String,
) -> Result<crate::models::SuccessfulResponse, Error<LogoutAllUserSessionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/{user_id}/logout_all_sessions",
        local_var_configuration.base_path,
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<LogoutAllUserSessionsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn disable_user2fa(
    configuration: &configuration::Configuration,
    params: DisableUser2faParams,
) -> Result<crate::models::SuccessfulResponse, Error<DisableUser2faError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/{user_id}/disable_2fa",
        local_var_configuration.base_path,
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DisableUser2faError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn enable_user(
    configuration: &configuration::Configuration,
    params: EnableUserParams,
) -> Result<crate::models::SuccessfulResponse, Error<EnableUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/{user_id}/enable",
        local_var_configuration.base_path,
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EnableUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_user_by_email(
    configuration: &configuration::Configuration,
    params: FetchUserByEmailParams,
) -> Result<crate::models::UserMetadata, Error<FetchUserByEmailError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let email = params.email;
    let include_orgs = params.include_orgs;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/email",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("email", &email.to_string())]);
    if let Some(ref local_var_str) = include_orgs {
        local_var_req_builder =
            local_var_req_builder.query(&[("include_orgs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FetchUserByEmailError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_user_by_id(
    configuration: &configuration::Configuration,
    params: FetchUserByIdParams,
) -> Result<crate::models::UserMetadata, Error<FetchUserByIdError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;
    let include_orgs = params.include_orgs;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/{user_id}",
        local_var_configuration.base_path,
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_orgs {
        local_var_req_builder =
            local_var_req_builder.query(&[("include_orgs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FetchUserByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_user_by_username(
    configuration: &configuration::Configuration,
    params: FetchUserByUsernameParams,
) -> Result<crate::models::UserMetadata, Error<FetchUserByUsernameError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let username = params.username;
    let include_orgs = params.include_orgs;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/username",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_orgs {
        local_var_req_builder =
            local_var_req_builder.query(&[("include_orgs", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("username", &username.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FetchUserByUsernameError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_users_by_emails(
    configuration: &configuration::Configuration,
    params: FetchUsersByEmailsParams,
) -> Result<Vec<crate::models::UserMetadata>, Error<FetchUsersByEmailsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let emails_query = params.emails_query;
    let include_orgs = params.include_orgs;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/emails",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_orgs {
        local_var_req_builder =
            local_var_req_builder.query(&[("include_orgs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&emails_query);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FetchUsersByEmailsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_users_by_ids(
    configuration: &configuration::Configuration,
    params: FetchUsersByIdsParams,
) -> Result<Vec<crate::models::UserMetadata>, Error<FetchUsersByIdsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_ids_query = params.user_ids_query;
    let include_orgs = params.include_orgs;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/user_ids",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_orgs {
        local_var_req_builder =
            local_var_req_builder.query(&[("include_orgs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&user_ids_query);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FetchUsersByIdsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_users_by_query(
    configuration: &configuration::Configuration,
    params: FetchUsersByQueryParams,
) -> Result<crate::models::UserPagedResponse, Error<FetchUsersByQueryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;
    let page_number = params.page_number;
    let order_by = params.order_by;
    let email_or_username = params.email_or_username;
    let include_orgs = params.include_orgs;
    let legacy_user_id = params.legacy_user_id;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/query",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder =
            local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_number {
        local_var_req_builder =
            local_var_req_builder.query(&[("page_number", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order_by {
        local_var_req_builder =
            local_var_req_builder.query(&[("order_by", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = email_or_username {
        local_var_req_builder =
            local_var_req_builder.query(&[("email_or_username", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_orgs {
        local_var_req_builder =
            local_var_req_builder.query(&[("include_orgs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = legacy_user_id {
        local_var_req_builder =
            local_var_req_builder.query(&[("legacy_user_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FetchUsersByQueryError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn fetch_users_by_usernames(
    configuration: &configuration::Configuration,
    params: FetchUsersByUsernamesParams,
) -> Result<Vec<crate::models::UserMetadata>, Error<FetchUsersByUsernamesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let usernames_query = params.usernames_query;
    let include_orgs = params.include_orgs;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/usernames",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_orgs {
        local_var_req_builder =
            local_var_req_builder.query(&[("include_orgs", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&usernames_query);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<FetchUsersByUsernamesError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn migrate_user(
    configuration: &configuration::Configuration,
    params: MigrateUserParams,
) -> Result<crate::models::CreatedUserResponse, Error<MigrateUserError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let migrate_user_request = params.migrate_user_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/migrate_user/",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&migrate_user_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MigrateUserError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_user_email(
    configuration: &configuration::Configuration,
    params: UpdateUserEmailParams,
) -> Result<crate::models::SuccessfulResponse, Error<UpdateUserEmailError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;
    let update_email_request = params.update_email_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/{user_id}/email",
        local_var_configuration.base_path,
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_email_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateUserEmailError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_user_metadata(
    configuration: &configuration::Configuration,
    params: UpdateUserMetadataParams,
) -> Result<crate::models::SuccessfulResponse, Error<UpdateUserMetadataError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;
    let update_metadata_request = params.update_metadata_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/{user_id}",
        local_var_configuration.base_path,
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_metadata_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateUserMetadataError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn update_user_password(
    configuration: &configuration::Configuration,
    params: UpdateUserPasswordParams,
) -> Result<crate::models::SuccessfulResponse, Error<UpdateUserPasswordError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let user_id = params.user_id;
    let update_password_request = params.update_password_request;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/{user_id}/password",
        local_var_configuration.base_path,
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_password_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateUserPasswordError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn clear_user_password(
    configuration: &configuration::Configuration,
    user_id: String,
) -> Result<crate::models::SuccessfulResponse, Error<ClearUserPasswordError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/{user_id}/clear_password",
        local_var_configuration.base_path,
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ClearUserPasswordError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn enable_user_can_create_orgs(
    configuration: &configuration::Configuration,
    user_id: String,
) -> Result<crate::models::SuccessfulResponse, Error<DisableUser2faError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/{user_id}/can_create_orgs/enable",
        local_var_configuration.base_path,
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DisableUser2faError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn disable_user_can_create_orgs(
    configuration: &configuration::Configuration,
    user_id: String,
) -> Result<crate::models::SuccessfulResponse, Error<DisableUser2faError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/user/{user_id}/can_create_orgs/disable",
        local_var_configuration.base_path,
        user_id = crate::apis::urlencode(user_id)
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DisableUser2faError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn invite_user_to_org(
    configuration: &configuration::Configuration,
    params: InviteUserToOrgRequest,
) -> Result<String, Error<InviteUserToOrgError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let invite_user_to_org_request = params;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/backend/v1/invite_user",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&invite_user_to_org_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(local_var_content)
    } else {
        let local_var_entity: Option<InviteUserToOrgError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
